# Vuex
>컴포넌트간 정보의 정달을 위해서 props와 event를 이용했다. 부모 컴포넌트에서 자식 컴포넌트로 정보를 전달하기 위햇 props를 이용했고, 자식 컴포넌트에서 부모 컴포넌트로 정보를 전달하기 위해서 event를 이용했다. 한 가지 주의할 점은 부모 컴포넌트로부터 전달받은 속성은 자식 컴포넌트에서 변경하지 않는다. 그렇기 때문에 자식 컴포넌트에서 부모 컴포넌트로부터 전달받은 속성을 직접 변경하는 것이 아니라 이벤트를 통해서 부모 컴포넌트에 변경 정보를 알려서 부모 컴포넌트 내부에서 변경하도록 해야 한다. 하지만 부모-자식 관계가 아니거나 계층 구조가 복잡해지면 어쩔 수 없이 이벤트 버스(Event Bus)객체를 사용해야 한다. 하지만 이벤트 버스 객체를 사용하는 방식도 대규모 애플리케이션을 개발하는 경우에는 복잡도를 증가시킬 수 밖에 없다. 이 때문에 대규모 애플리케이션의 상태를 관리할 수 있는 상태 관리 라이브러리가 필요한 것이다. Vuex는 이벤트 버스 객체를 사용하여 코드가 복잡해지는 문제점과 공유 객체의 변경 추적이 힘들다는 문제점을 해결할 수 있는 좋은 패턴을 제공한다.

# Vuex란?
>Vuex는 Vue.js 애플리케이션에서 상태 관리 패턴을 지원하는 라이브러리이다. 애플리케이션 내부의 모든 컴포넌트들이 공유하는 중앙 집중화된 상태 정보 저장소 역할을 하며 상태 변경을 투명하게 할 수 있다. 각 컴포넌트가 공유하는 상태 데이터는 전역에서 저장소(store) 객체를 통해서 관리한다. 이와 같은 방식으로 부모에서 자식으로 또 그 자식으로 props를 이용해 속성을 계속해서 전달하지 않아도 되고, 상태 데이터를 변경하기 위해 부모 컴포넌트로 이벤트를 발생시키지 않아도 된다. 단지 컴포넌트에 저장소(Store)객체의 데이터와 메서드들을 로컬 컴포넌트의 계산형 속성이나 메서드에 연결하기만 하면 된다.

Vuex 아키텍처의 데이터 처리 흐름은 단방향 데이터 흐름 이다. 전체적인 처리 흐름은 다음과 같다.
1) 컴포넌트가 액션(Action)을 일으킨다.
2) 액션에서는 외부 API를 호출한 뒤 그 결과를 이용해 변이(Mutation)를 일으킨다.(만일 외부 API가 없으면 생략).
3) 변이에서는 액션의 결과를 받아 상태(State)를 변경한다. 이단계는 추적할 수 있기 때문에 Vue.js DevTools와 같은 도구를 이용하면 상태변경의 내역을 모두 확인할 수 있다.
4) 변이에 의해 변경된 상태는 다시 컴포넌트에 바인딩되어 화면을 갱신한다.

# 상태와 변이
상태(state)와 변이(mutation)는 Vuex 저장소(store) 내부의 핵심 요소이다. 상태는 애플리케이션에서 관리해야 할 중요한 데이터이며, 변이는 상태를 변경하는 함수들을 보유하고 있는 객체이다. 전역에서 Vue.use(Vuex) 코드의 실행으로 애플리케이션 내부의 모든 컴포넌트가 저장소의 상태, 변이 객체에 접근할 수 있다. 상태는 반드시 변이를 통해서만 변경하도록 해야 한다.

# Vuex의 상태를 왜 컴포넌트의 계산형 속성에 바인딩하는가?
이는 바로 컴포넌트 수준에서 상태를 직접 변경하지 않았으면 하기 때문이다. 현재는 수정이 가능하긴 하다. 직접 변경하는 것을 막을 때 쓰는 옵션이 Vuex Store 객체의 strict:true 옵션이다. 이 옵션을 사용하면 컴포넌트에서 직접 상태를 변경하려 할 경우 오류를 발생시킨다.

```
const store = new Vuex.Store({
    state,
    mutations,
    actions,
    strict : true
})
export default store;
```

하지만 실무에서는 strict : true 옵션을 사용하지 말자. 엄격하게 검증하기 위해 오히려 성능이 저하된다. 개발할 때 단방향 데이터 흐름 규칙에 위배되는 것이 있지는 않은지를 확인하기 위해서만 사용하고 운영 환겨에 배포할 때는 false로 지정하자.

# 게터
게터는 저장소(Store) 수준의 계산형 속성(Computed Property)이라고 말할 수 있다. 컴포넌트에서 계산형 속성이 필수가 아니듯 게터 또한 저장소 내에서 필수적으로 사용해야 하는 것은 아니다. 하지만 적절하게 사용하면 컴포넌트에서의 코드 작성이 편리해진다.

# 액션
변이(mutation)는 상태를 변경할 수 있지만 한 가지 단점을 가지고 있다. 바로 동기적인 작업만 수행한다는 것이다. 예를 들어 서버와 통신하여 데이터를 가져온 후 상태 데이터를 변경하는 경우에 이 작업은 비동기적으로 처리되어야 하는데 변이는 동기적인 처리를 수행하므로 변이만으로는 문제 해결이 불가능하다. 그래서 변이의 기능에서 외부 리소스 액세스를 비롯한 비동기 처리가 필요한 API 호출 기능을 수행하기 위해 액션(Action)을 분리해낼 수밖에 없다. 단지 보기 좋게 기능을 분리하는 것이 아니다. 기능적인 필요성이 분명하다.

* 동기적 작업과 비동기적 작업 방식의 차이
동기적 작업 방식은 작업을 요청하고 작업이 완료할 때까지 대기하였다가 다음 작업을 처리하는 방법이고 비동기적 작업 방식은 작업을 요청할 때 미리 작업이 완료될 때 실행할 기능을 정의해두고 다른 작업을 할 수 있다. 작업이 완료되면 미리 등록해둔 기능을 실행하도록 하는 작업 방식이다. 동기적 처리 방식은 약간의 지연이 발생하는 시간 동안 아무런 작업을 하지 못하고 대기하고 브라우저가 먹통이 되어 버린다. 작업이 완료되면 다음 단계의 처리를 수행한다. 반면 비동기적인 처리는 요청한 작업이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있다. 요청한 작업이 완료되면 미리 등록해둔 함수 기능을 실행할 수 있는 것이다.



# 대규모 애플리케이션에서의 Vuex 사용


# 연락처 애플리케이션에 Vuex 적용하기

